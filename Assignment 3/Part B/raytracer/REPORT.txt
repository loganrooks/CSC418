
This Project is a collaboration between Logan Rooks and Christopher Sheedy. There are two
parts to the project, Part A and Part B, which have been submitted in folders of the same 
name. To access either part, change your folder to a3/Part A/raytracer, or a3/Part B/raytracer. 
First we will describe Part A:

#### PART A ####

**Running the code**

To compile the code you must be in a3/Part A/raytracer. Simply execute the command "make
raytracer", and then call "./raytracer". Note that we have provided three images to 
demonstrate the working of our program, but running raytracer will only generate the 
image with all three terms of the phong model.

**The code**

We were provided with starter code for all aspects of the raytracer except for the following:

a) Casting rays towards each pixel of the image plane
	For this section we needed to convert the ray to world Space. This was done By Logan Rooks
	in raytracer.cpp under Raytracer::render. Christopher Sheedy added an epsilon term to
	eliminate noise/error in the image. The epsilon term was added using advice from the discussion board.

b) ray-sphere intersection
	For this section we needed to comnplete the UnitSphere::intersect function. This was done
	by Christopher Sheedy, and can be found in scene_object.cpp. For both part b) and c) the 
	course notes were used as reference.

c) ray-unit square intersection
	For this sections we needed to complete the UnitSquare::intersect function. This was done 
	by Logan Rooks, and can be found in scene_object.cpp

d) Phong illumination
	For this section we needed to complete Phong illumination in the PointLight::shade 
	function. This was done by Christopher Sheedy and can be found in light_source.cpp.

#### PART B ####

**Running the code**

To compile the code you must be in a3/Part B/raytracer. Execute the command "make raytracer" and then call "./raytracer".
Note that we have provided all images to demonstrate the working of our program, and running raytracer WILL generate that full set of images.

**The code**

Note that while each section was primarily completed by the student indicated, There was some degree of collaboration
that is not explicitly documented.

To better demonstrate the techniques we implemented, we designed several new scenes to render. A standardized scene was
created by Christopher Sheedy called simple_scene to standardize the demonstration. The environment consists of a square
 room with a mirror or painting on one side, a light source in the back corner, and numerous objects floating in front
 of the mirror/painting. Two other environments, based on the Portal games, were created to showcase the effects in a
 flashier way using textures and were created by Logan Rooks. The first one is called portal_scene and consists of two
 portals, a companion cube, "orange goo" and texture mapped floor, ceiling and walls. One of the walls is missing since
 the portals at this point are actually just mirrors and interesting scenes can be set up by placing objects behind the
 camera. The third scene is simple_portal_scene, which includes a small texture mapped rooms with two portals (that
 actual work as portals) as a bonus. It was used just to demonstrate the portal effect.

 To keep our main file clean, we created two new files scenes.cpp and experiments.cpp with their corresponding headers.
 Our scenes are defined and set up as functions in scenes.cpp, while the experiments.cpp contains functions that render
 and save images of scenes portraying each of the effects.

 The completed renderings are in "renderings/", the environment textures for environment mapping are in "environments/"
 and the other textures used are in "textures".

i) Recursive Ray Tracing (Christopher Sheedy)
	For this section we needed to modify the Raytracer::shadeRay function. This was done by
	Christopher Sheedy, and can be found in raytracer.cpp (note that this is in the Part B folder). To implement recursive
	ray tracing, we simply calculated the reflected ray ([1] from stack-exchange), and
	called shadeRay again on it. Then the two colors were combined, with the material property
	reflectIndex (which we added in util.cpp) determining the linear combination. For example, a mirror would have a
	reflectIndex of 1.0. In addition, we added an epsilon term to the reflected ray to reduce noise/errors. The demo
	images for this section are saved as recurseRT#.bmp

ii) Hard Shadows (Logan Rooks)
	For this section we needed to modify the Raytracer::computeShading and PointLight::shade functions. This was done by
	 extending a shadow ray from the point of intersection to each of the point lights and only adding the ambient
	 component of the shading to the ray if the shadow ray intersects an object.

iii) Anti-Aliasing (Christopher Sheedy)
	For this section we implemented 8x anti-aliasing by creating a new function, Raytracer::antiAliasRender8x in raytracer.cpp.
	This was done by Christopher Sheedy. Much of the function is exactly the same as in Raytracer::render, except for the creation of rays.
	In render, each pixel gets a single ray through the center of that pixel on the image plane. In antiAliasRender8x,
	we split the pixel on the image plane into 8 quadrants, and then select two random points in each quadrant.
	The idea for this came from wikipedia, it is similar to "Jittering" from [2]. Each ray is shaded, and then the average
	of all 8 rays is computed.

iv) Extended light sources (Christopher Sheedy)
	For this section we added an extended light source in main.cpp.
	This was done by Christopher Sheedy.
	We approximated the light source by adding a large number of point light sources.

v) Environment Mapping (Logan Rooks)
    The environment mapping was implemented by mapping rays that did not intersect with any object t

Sources:

[1] Reflection vector equation
https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa

[2] https://en.wikipedia.org/wiki/Supersampling

Texture Sources:
8k earth and